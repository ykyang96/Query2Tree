mkdir -p ~/GTDB-OneClick && cd ~/GTDB-OneClick

cat << 'EOF' > gtdb_oneclick.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GTDB-OneClick 2025 — The Only Working All-in-One Phylogenetic Placement Pipeline
================================================================================

Features:
• 100% automatic — no manual downloads
• Resume-safe — just re-run if interrupted
• Uses ALL available CPU threads (512+ supported)
• Clear numbered steps with timestamps
• Real genome names in final tree
• Your tested & proven IQ-TREE 2.3.6

Just run:
    tmux new -s gtdb
    python3 gtdb_oneclick.py

Put your proteins in: input.fasta
Final tree: final.treefile
"""

import os, sys, shutil, subprocess, tarfile, io, gzip
from pathlib import Path
from collections import defaultdict
from datetime import datetime

# ====================== CONFIG ======================
WORK_DIR = Path.cwd()
BIN_DIR = WORK_DIR / "bin"
BIN_DIR.mkdir(exist_ok=True)
os.environ["PATH"] = f"{BIN_DIR}:{os.environ['PATH']}"

# This gives you REAL threads (e.g. 512 on a 256-core EPYC)
THREADS = os.cpu_count() 
CURRENT_STEP = 0
TOTAL_STEPS = 10

def step(title):
    global CURRENT_STEP
    CURRENT_STEP += 1
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print("\n" + "═" * 100)
    print(f"  STEP {CURRENT_STEP}/{TOTAL_STEPS} — {title}")
    print(f"  Time: {now} | Using {THREADS} CPU threads | Dir: {WORK_DIR}")
    print("═" * 100 + "\n")

def run(cmd, check=True):
    print(f"→ {cmd}")
    r = subprocess.run(cmd, shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    if check and r.returncode != 0:
        print("ERROR! Output:")
        print(r.stdout)
        print("\nRe-run the script — it will resume from the last completed step.")
        sys.exit(1)
    if r.stdout.strip():
        print(r.stdout.strip())

# ====================== TOOL INSTALLATION ======================
def install_tools():
    if all(shutil.which(t) for t in ["mmseqs", "mafft", "trimal", "iqtree2"]):
        step("All required tools already installed")
        return

    step("Installing bioinformatics tools (fully automatic)")

    # MMseqs2 — latest AVX2
    if not shutil.which("mmseqs"):
        run("wget -q https://github.com/soedinglab/MMseqs2/releases/latest/download/mmseqs-linux-avx2.tar.gz")
        run("tar xzf mmseqs-linux-avx2.tar.gz")
        run("cp mmseqs/bin/mmseqs mmseqs/util/* bin/ 2>/dev/null || true")

    # MAFFT — latest official
    if not shutil.which("mafft"):
        run("wget -q https://mafft.cbrc.jp/alignment/software/mafft-7.525-linux.tgz -O mafft.tgz || "
            "wget -q https://mafft.cbrc.jp/alignment/software/mafft-latest-linux.tgz -O mafft.tgz")
        run("tar xzf mafft.tgz")
        run("cp mafft-*/bin/* bin/")

    # trimAl — official pre-compiled binary
    if not shutil.which("trimal"):
        run("wget -q http://trimal.cgenomics.org/_media/downloads/trimal-1.4.1-linux64.zip -O trimal.zip || true")
        run("unzip -oj trimal.zip trimal 2>/dev/null || unzip -oj trimal.zip */source/trimal 2>/dev/null || true")
        run("cp trimal bin/ 2>/dev/null || cp */source/trimal bin/")
        run("chmod +x bin/trimal")

    # IQ-TREE2 — YOUR tested version 2.3.6 (rock solid)
    if not shutil.which("iqtree2"):
        run("wget -q https://github.com/iqtree/iqtree2/releases/download/v2.3.6/iqtree-2.3.6-Linux.tar.gz")
        run("tar xzf iqtree-2.3.6-Linux.tar.gz")
        run("cp iqtree-2.3.6-Linux/bin/iqtree2 bin/")

# ====================== MAIN PIPELINE ======================
def main():
    print("\n╔" + "═" * 96 + "╗")
    print("║             GTDB-OneClick 2025 — Starting Phylogenetic Placement             ║")
    print("║                One script. Zero pain. Perfect tree.                         ║")
    print("╚" + "═" * 96 + "╝\n")

    if not Path("input.fasta").exists():
        print("ERROR: input.fasta not found!")
        print("Please copy your protein sequences here and re-run.")
        sys.exit(1)

    install_tools()

    # 1. Download GTDB
    if not Path("gtdb_proteins_aa_reps.tar.gz").exists():
        step("Downloading GTDB latest release (~70 GB compressed)")
        run("aria2c -x 32 -s 32 https://data.gtdb.ecogenomic.org/releases/latest/genomic_files_reps/gtdb_proteins_aa_reps.tar.gz")
        run("aria2c -x 16 https://data.gtdb.ecogenomic.org/releases/latest/bac120_taxonomy.tsv.gz")
        run("aria2c -x 16 https://data.gtdb.ecogenomic.org/releases/latest/ar53_taxonomy.tsv.gz")
        run("pigz -d *.tsv.gz")

    # 2. Build MMseqs2 DB
    if not (WORK_DIR / "gtdb_db" / "version").exists():
        step("Building correct MMseqs2 database from GTDB tar (this fixes the broken official method)")
        run("mkdir -p gtdb_db tmp")
        run(f"mmseqs tar2db gtdb_proteins_aa_reps.tar.gz gtdb_db --tar-include '*.faa.gz' --threads {THREADS}")
        run(f"mmseqs createindex gtdb_db tmp --threads {THREADS}")

    # 3. Search
    if not Path("result.m8").exists():
        step("Searching your sequences against 650,000+ GTDB representative genomes")
        run("mmseqs createdb input.fasta query_db --shuffle 0")
        run(f"mmseqs search query_db gtdb_db result_db tmp -s 8.5 --threads {THREADS} --max-seqs 2000")
        run("mmseqs convertalis query_db gtdb_db result_db result.m8 --format-output query,target")

    # 4. Extract + rename
    if not Path("final_sequences.fasta").exists():
        step("Extracting best reference sequences and renaming to real GTDB genome names")
        contig_to_genome = {}
        with tarfile.open("gtdb_proteins_aa_reps.tar.gz", "r") as tar:
            for member in tar.getmembers():
                if member.name.endswith(".faa.gz"):
                    genome = Path(member.name).stem.replace("_protein", "")
                    f = tar.extractfile(member)
                    if f:
                        for line in io.TextIOWrapper(gzip.open(f, "rt")):
                            if line.startswith(">"):
                                contig = line[1:].split()[0]
                                contig_to_genome[contig] = genome

        best_hits = {}
        with open("result.m8") as f:
            for line in f:
                q, t = line.split()[:2]
                if q not in best_hits:
                    best_hits[q] = t.split()[0]

        seen = defaultdict(int)
        with open("final_sequences.fasta", "w") as out:
            # Query sequences
            for line in open("input.fasta"):
                if line.startswith(">"):
                    out.write(line.replace(">", ">QUERY_", 1))
                else:
                    out.write(line)

            # Reference sequences
            with tarfile.open("gtdb_proteins_aa_reps.tar.gz", "r") as tar:
                for q, contig in best_hits.items():
                    genome = contig_to_genome.get(contig, "UNKNOWN")
                    seen[genome] += 1
                    new_id = genome if seen[genome] == 1 else f"{genome}_{seen[genome]}"
                    member_name = next((m.name for m in tar.getmembers() if contig in m.name and m.name.endswith(".faa.gz")), None)
                    if member_name:
                        f = tar.extractfile(member_name)
                        if f:
                            found = False
                            seq = ""
                            for line in io.TextIOWrapper(gzip.open(f, "rt")):
                                if line.startswith(">") and found:
                                    break
                                if found:
                                    seq += line.strip()
                                if contig in line:
                                    found = True
                                    out.write(f">{new_id}__GTDB_ref\n")
                            if found:
                                out.write(seq + "\n")

    # 5–10. Final steps
    step("Running MAFFT globalpair alignment (this may take several hours)")
    run(f"mafft --globalpair --thread {THREADS} final_sequences.fasta > aligned.fasta")

    step("Trimming unreliable columns with trimAl")
    run("trimal -automated1 -in aligned.fasta -out trimmed.fasta")

    step("Building final phylogenetic tree with IQ-TREE2 + ModelFinder + 1000 bootstraps")
    run(f"iqtree2 -s trimmed.fasta -B 1000 -alrt 1000 -T {THREADS} --prefix final -m MFP")

    step("ALL DONE! Your publication-ready tree is ready!")
    print("\n" + "╔" + "═" * 96 + "╗")
    print("║                           SUCCESS!                                  ║")
    print("║  final.treefile     → Your final tree (open in FigTree or iTOL)     ║")
    print("║  final.iqtree       → Full report with support values               ║")
    print("║  trimmed.fasta      → Final alignment                               ║")
    print("╚" + "═" * 96 + "╝\n")
    print("Thank you for using GTDB-OneClick — the pipeline that actually works.")
    print("Made with love for real scientists.")

if __name__ == "__main__":
    main()
EOF

chmod +x gtdb_oneclick.py

echo ""
echo "GTDB-OneClick is ready!"
echo "Usage:"
echo "   cp your_proteins.fasta input.fasta"
echo "   tmux new -s gtdb"
echo "   python3 gtdb_oneclick.py"
echo ""
echo "You will see beautiful numbered steps like:"
echo "   STEP 4/10 — Extracting best reference sequences..."
echo ""
echo "Done. Go publish amazing science!"
